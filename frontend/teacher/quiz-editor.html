<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Editor - PopQuiz</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Anton&family=Poppins:wght@300;400;600&display=swap');
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; font-family: 'Poppins', sans-serif; overflow-y: auto; }
        .questions-page-container { display: flex; justify-content: center; align-items: center; flex-direction: column; min-height: 100vh; background-color: #000; color: #fff; position: relative; text-align: center; padding: 150px 20px 50px 20px; box-sizing: border-box; }
        .grid-background { position: fixed; bottom: 0; left: 0; width: 100%; height: 50%; background-image: linear-gradient(to right, rgba(255, 255, 255, 0.4) 1px, transparent 1px), linear-gradient(to bottom, rgba(255, 255, 255, 0.4) 1px, transparent 1px); background-size: 40px 40px; transform-style: preserve-3d; transform: perspective(500px) rotateX(75deg); z-index: 0; }
        .header { position: absolute; top: 40px; left: 40px; right: 40px; display: flex; justify-content: space-between; align-items: center; z-index: 2; }
        .logo { font-family: 'Anton', sans-serif; font-size: 1.8rem; font-weight: 400; letter-spacing: 1px; }
        .header-nav { display: flex; align-items: center; gap: 20px; }
        .nav-btn { color: #fff; text-decoration: none; font-weight: 600; border: 2px solid #fff; padding: 8px 15px; border-radius: 50px; transition: all 0.3s ease; font-size: 0.9rem; }
        .nav-btn:hover { background-color: #fff; color: #000; }
        .content-wrapper { position: relative; z-index: 1; width: 100%; max-width: 800px; }
        .content-wrapper h1 { font-size: 2.5rem; font-weight: 300; letter-spacing: 4px; margin-bottom: 50px; }
        .questions-list { display: flex; flex-direction: column; gap: 20px; margin-bottom: 40px; }
        .question-item { display: flex; align-items: center; gap: 15px; border: 2px solid #fff; border-radius: 25px; padding: 20px 25px; text-align: left; }
        .question-text { flex-grow: 1; line-height: 1.6; font-size: 1rem; }
        .question-actions button { background: none; border: none; cursor: pointer; padding: 5px; line-height: 0; }
        .question-actions svg { width: 20px; height: 20px; stroke: #aaa; stroke-width: 2; fill: none; transition: stroke 0.3s; }
        .question-actions button:hover svg { stroke: #fff; }
        .edit-textarea { width: 100%; background-color: #111; color: #fff; border: 1px solid #555; border-radius: 10px; padding: 10px; font-family: 'Poppins', sans-serif; font-size: 1rem; resize: vertical; min-height: 60px; }
        .bottom-actions { display: flex; justify-content: space-between; align-items: center; gap: 20px; }
        .action-button { padding: 14px 35px; border: 2px solid #fff; border-radius: 50px; color: #fff; background-color: transparent; text-decoration: none; font-weight: 600; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; }
        .action-button.primary { background-color: #fff; color: #000; }
        .action-button.primary:hover { background-color: transparent; color: #fff; }
        .action-button:hover { background-color: #fff; color: #000; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 100; display: none; justify-content: center; align-items: center; }
        .modal-content { background-color: #111; padding: 30px 40px; border-radius: 15px; border: 2px solid #fff; width: 100%; max-width: 400px; text-align: center; color: #fff; /* FIX: Added this line */ }
        .modal-content h2 { margin-top: 0; }
        .modal-content input { width: 100%; padding: 12px; margin: 20px 0; border-radius: 10px; border: 1px solid #555; background: #222; color: #fff; font-size: 1rem; box-sizing: border-box;}
        .modal-actions { display: flex; justify-content: flex-end; gap: 15px; }
        .export-container { position: relative; display: inline-block; }
        .export-options { display: none; position: absolute; bottom: 100%; right: 0; margin-bottom: 10px; background-color: #111; border: 2px solid #fff; border-radius: 15px; z-index: 10; min-width: 200px; overflow: hidden; }
        .export-option { padding: 12px 20px; color: #fff; cursor: pointer; transition: background-color 0.3s; text-align: left; }
        .export-option:hover { background-color: #333; }
    </style>
</head>
<body>
    <div class="questions-page-container">
        <div class="grid-background"></div>
        <header class="header">
            <div class="logo">POPQUIZ</div>
            <div class="header-nav"><a href="dashboard.html" class="nav-btn">Dashboard</a><a href="../index.html" class="nav-btn">Logout</a></div>
        </header>
        <div class="content-wrapper">
            <h1>QUIZ EDITOR</h1>
            <div id="questions-list" class="questions-list"></div>
            <div class="bottom-actions">
                <button id="add-question-btn" class="action-button">ADD QUESTION</button>
                <div>
                    <button id="save-quiz-btn" class="action-button">SAVE QUIZ</button>
                    <div class="export-container"><button id="export-btn" class="action-button primary">EXPORT</button><div id="export-options" class="export-options"><div class="export-option" data-format="pdf">Export to PDF</div><div class="export-option" data-format="word">Export to Word</div><div class="export-option" data-format="clipboard">Copy to Clipboard</div></div></div>
                </div>
            </div>
        </div>
    </div>
    <div id="save-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Save Quiz</h2><p>Enter a name for this quiz to save it to your dashboard.</p><input type="text" id="quiz-name-input" placeholder="e.g., OS Midterm Review"><div class="modal-actions"><button id="cancel-save-btn" class="action-button">Cancel</button><button id="confirm-save-btn" class="action-button primary">Save</button></div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const questionsList = document.getElementById('questions-list'), addQuestionBtn = document.getElementById('add-question-btn'), saveQuizBtn = document.getElementById('save-quiz-btn'), saveModal = document.getElementById('save-modal'), cancelSaveBtn = document.getElementById('cancel-save-btn'), confirmSaveBtn = document.getElementById('confirm-save-btn'), quizNameInput = document.getElementById('quiz-name-input'), exportBtn = document.getElementById('export-btn'), exportOptions = document.getElementById('export-options');
            const iconEdit = `<svg viewBox="0 0 24 24"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`, iconSave = `<svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>`, iconRegen = `<svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>`;

            // helper to get query param id
            const params = new URLSearchParams(window.location.search);
            const editingQuizId = params.get('id');

            let initialQuestions = ["Explain the differences between preemptive and non-preemptive scheduling.", "What is paging and how does it differ from segmentation?", "Define deadlock. What are the four necessary conditions for a deadlock?", "Explain contiguous, linked, and indexed allocation methods."];

            // Render helper
            const createQuestionElement = (text) => { const item = document.createElement('div'); item.className = 'question-item'; item.innerHTML = `<div class="question-text">${text}</div><div class="question-actions"><button class="edit-btn" title="Edit">${iconEdit}</button><button class="regen-btn" title="Regenerate">${iconRegen}</button></div>`; questionsList.appendChild(item); };
            const renderQuestions = (arr) => { questionsList.innerHTML = ''; arr.forEach(q => createQuestionElement(q)); };

            // meta used for generation/regeneration
            let currentMeta = { topic: 'General', bloom_level: 'Understanding', question_type: 'Short Answer' };

            // If a quiz id is present, fetch it from backend and populate editor
            const token = localStorage.getItem('popquiz_token');
            if (editingQuizId) {
                if (!token) {
                    alert('You must be logged in to view this quiz. Redirecting to login.');
                    window.location.href = 'faculty-login.html';
                    return;
                }
                fetch(`http://localhost:8000/quizzes/${editingQuizId}`, {
                    method: 'GET',
                    headers: { 'Authorization': 'Bearer ' + token }
                }).then(async r => {
                    if (!r.ok) {
                        const body = await r.json().catch(() => ({}));
                        alert(body.detail || 'Unable to load quiz.');
                        return;
                    }
                    return r.json();
                }).then(data => {
                    if (!data) return;
                    // Use persisted questions and meta
                    const persisted = data;
                    if (Array.isArray(persisted.questions) && persisted.questions.length > 0) {
                        initialQuestions = persisted.questions;
                    }
                    // capture persisted meta (topic, bloom_level, question_type)
                    if (persisted.topic) currentMeta.topic = persisted.topic;
                    if (persisted.bloom_level) currentMeta.bloom_level = persisted.bloom_level;
                    if (persisted.question_type) currentMeta.question_type = persisted.question_type;
                    // prefill name and allow save to update
                    if (persisted.name) quizNameInput.value = persisted.name;
                    renderQuestions(initialQuestions);
                }).catch(err => {
                    console.error('Failed to fetch quiz:', err);
                    alert('Failed to fetch the quiz from backend.');
                });
            } else {
                // If generated questions were passed from generator, use them
                try {
                    const gen = sessionStorage.getItem('generated_questions');
                    if (gen) {
                        const parsed = JSON.parse(gen);
                        if (Array.isArray(parsed) && parsed.length > 0) initialQuestions = parsed;
                    }
                } catch (e) { console.warn('No generated questions in sessionStorage'); }
                // If generator meta exists in sessionStorage, use it for regenerations
                try {
                    const metaRaw = sessionStorage.getItem('generated_meta');
                    if (metaRaw) {
                        const parsedMeta = JSON.parse(metaRaw);
                        if (parsedMeta.topic) currentMeta.topic = parsedMeta.topic;
                        if (parsedMeta.bloom_level) currentMeta.bloom_level = parsedMeta.bloom_level;
                        if (parsedMeta.question_type) currentMeta.question_type = parsedMeta.question_type;
                    }
                } catch (e) { /* ignore */ }
                renderQuestions(initialQuestions);
            }

            questionsList.addEventListener('click', (e) => {
                const button = e.target.closest('button'); if (!button) return;
                const questionItem = button.closest('.question-item'), questionTextDiv = questionItem.querySelector('.question-text');
                if (button.classList.contains('edit-btn')) {
                    const isEditing = button.classList.contains('is-editing');
                    if (isEditing) { const textarea = questionTextDiv.querySelector('.edit-textarea'); questionTextDiv.textContent = textarea.value; button.innerHTML = iconEdit; button.title = 'Edit'; button.classList.remove('is-editing'); }
                    else { const currentText = questionTextDiv.textContent; questionTextDiv.innerHTML = `<textarea class="edit-textarea">${currentText}</textarea>`; button.innerHTML = iconSave; button.title = 'Save'; button.classList.add('is-editing'); }
                }
                if (button.classList.contains('regen-btn')) {
                    // regenerate this single question by asking the backend for 1 new question
                    const prevText = questionTextDiv.textContent;
                    questionTextDiv.textContent = 'Regenerating...';
                    (async () => {
                        // Note: backend expects `num_questions` (not `num`). Use matching field name.
                        const payload = { topic: currentMeta.topic || 'General', question_type: currentMeta.question_type || 'Short Answer', bloom_level: currentMeta.bloom_level || 'Understanding', num_questions: 1 };
                        try {
                            const hasToken = Boolean(localStorage.getItem('popquiz_token'));
                            const url = hasToken ? 'http://localhost:8000/generate_questions' : 'http://localhost:8000/test/generate_questions';
                            const headers = { 'Content-Type': 'application/json' };
                            if (hasToken) headers['Authorization'] = 'Bearer ' + localStorage.getItem('popquiz_token');
                            const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(payload) });
                            if (!res.ok) {
                                const body = await res.json().catch(() => ({}));
                                console.warn('Regenerate failed', res.status, body);
                                questionTextDiv.textContent = prevText;
                                // Make error message readable (handle validation arrays/objects)
                                const readable = body && body.detail ? (typeof body.detail === 'string' ? body.detail : JSON.stringify(body.detail)) : 'Failed to regenerate question';
                                alert(readable);
                                return;
                            }
                            const data = await res.json().catch(() => null);
                            let newQ = null;
                            if (!data) newQ = null;
                            else if (Array.isArray(data)) newQ = data[0];
                            else if (Array.isArray(data.questions)) newQ = data.questions[0];
                            else if (Array.isArray(data.generated_questions)) newQ = data.generated_questions[0];
                            else if (data.question) newQ = data.question;
                            else newQ = JSON.stringify(data);

                            if (newQ) questionTextDiv.textContent = newQ;
                            else { questionTextDiv.textContent = prevText; alert('No question returned from server'); }
                        } catch (err) {
                            console.error('Regeneration error', err);
                            questionTextDiv.textContent = prevText;
                            alert('Regeneration failed â€” see console for details');
                        }
                    })();
                }
            });

            addQuestionBtn.addEventListener('click', () => { createQuestionElement("Click the edit button to change this new question."); questionsList.lastChild.scrollIntoView({ behavior: 'smooth' }); });
            exportBtn.addEventListener('click', (e) => { e.stopPropagation(); exportOptions.style.display = exportOptions.style.display === 'block' ? 'none' : 'block'; });
            exportOptions.addEventListener('click', (e) => { const format = e.target.dataset.format; if (!format) return; if (format === 'clipboard') { const allQuestions = Array.from(questionsList.querySelectorAll('.question-text')).map((q, i) => `${i + 1}. ${q.textContent}`).join('\n'); navigator.clipboard.writeText(allQuestions).then(() => { alert('Questions copied to clipboard!'); }); } else { alert(`Export to ${format.toUpperCase()} is a future feature!`); } exportOptions.style.display = 'none'; });
            window.addEventListener('click', () => { if (exportOptions.style.display === 'block') { exportOptions.style.display = 'none'; } });
            saveQuizBtn.addEventListener('click', () => { saveModal.style.display = 'flex'; });
            cancelSaveBtn.addEventListener('click', () => { saveModal.style.display = 'none'; });

            // Save handler: POST for new quiz, PUT for existing quiz id
            confirmSaveBtn.addEventListener('click', () => {
                const quizName = quizNameInput.value.trim();
                if (!quizName) { alert('Please enter a name for your quiz.'); return; }
                // gather questions
                const allQuestions = Array.from(questionsList.querySelectorAll('.question-text')).map(q => q.textContent.trim());
                const meta = JSON.parse(sessionStorage.getItem('generated_meta') || '{}');
                const payload = { name: quizName, questions: allQuestions, topic: meta.topic || 'General', bloom_level: meta.bloom_level || 'Understanding', question_type: meta.question_type || 'Short Answer' };

                const t = localStorage.getItem('popquiz_token');
                if (!t) { alert('You must be logged in to save a quiz. Redirecting to login.'); window.location.href = 'faculty-login.html'; return; }

                const isUpdate = Boolean(editingQuizId);
                const url = isUpdate ? `http://localhost:8000/quizzes/${editingQuizId}` : 'http://localhost:8000/quizzes';
                const method = isUpdate ? 'PUT' : 'POST';

                fetch(url, {
                    method: method,
                    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + t },
                    body: JSON.stringify(payload)
                }).then(async r => {
                    const body = await r.json().catch(() => ({}));
                    return { ok: r.ok, status: r.status, body };
                }).then(result => {
                    if (!result.ok) {
                        alert(result.body.detail || 'Save failed');
                        return;
                    }
                    alert(`Quiz "${quizName}" ${isUpdate ? 'updated' : 'saved'} successfully!`);
                    saveModal.style.display = 'none'; quizNameInput.value = ''; sessionStorage.removeItem('generated_questions'); sessionStorage.removeItem('generated_meta');
                    window.location.href = 'dashboard.html';
                }).catch(err => {
                    console.error(err);
                    alert('Unable to reach backend. Make sure the backend is running at http://localhost:8000');
                });
            });
        });
    </script>
</body>
</html>

